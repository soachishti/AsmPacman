Microsoft (R) Macro Assembler Version 6.15.8803		    08/30/15 16:16:02
Pacman.asm						     Page 1 - 1


				; 214 dots
				; Game over when enemy col and row equal pacmanMov col and row
				; Randomness of enemy movement
				; Enemy only trigger after colliding
				;   - Try to move when turn comes
				; What will happen when pacman eat o

				include irvine32.inc
			      C ; Include file for Irvine32.lib             (Irvine32.inc)
			      C 
			      C INCLUDE SmallWin.inc		; MS-Windows prototypes, structures, and constants
			      C .NOLIST
			      C .LIST
			      C 
			      C .NOLIST
			      C .LIST
			      C 
				include macros.inc
			      C .NOLIST
			      C .LIST
			      C 
				INCLUDELIB user32.lib
 = 00000025			VK_LEFT		EQU		000000025h
 = 00000026			VK_UP		EQU		000000026h
 = 00000027			VK_RIGHT	EQU		000000027h
 = 00000028			VK_DOWN		EQU		000000028h
 = 0000004F			maxCol      EQU     79
 = 00000016			maxRow      EQU     22

				GetKeyState PROTO, nVirtKey:DWORD

 00000004			movement STRUCT
 00000000  00			    up BYTE 0
 00000001  00			    down BYTE 0
 00000002  00			    left BYTE 0
 00000003  00			    right BYTE 0
				movement ENDS

 0000000A			enemyInfo STRUCT
 00000000  1A			    col     BYTE 26
 00000001  09			    row     BYTE 9
 00000002  00			    up      BYTE 0
 00000003  00			    down    BYTE 0
 00000004  00			    left    BYTE 0
 00000005  01			    right   BYTE 1
 00000006  0000			    delay   WORD 0
 00000008  1A			    hrow     BYTE 26
 00000009  09			    hcol     BYTE 9
				enemyInfo ENDS

 00000000			.data
				    include data.asm
 00000000 2B 2D 2D 2D 2D      C     map BYTE "+---------------------------------------------------+"
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2B
 00000035  7C 20 2E 20 2E     C         BYTE "| . . . . . .  . . . . . . . . .  .  . . . . . . .  |"
	   20 2E 20 2E 20
	   2E 20 2E 20 20
	   2E 20 2E 20 2E
	   20 2E 20 2E 20
	   2E 20 2E 20 2E
	   20 2E 20 20 2E
	   20 20 2E 20 2E
	   20 2E 20 2E 20
	   2E 20 2E 20 2E
	   20 20 7C
 0000006A  7C 20 2E 20 2B     C         BYTE "| . +------+ . +------+ . | . +------+ . +------+ . |"
	   2D 2D 2D 2D 2D
	   2D 2B 20 2E 20
	   2B 2D 2D 2D 2D
	   2D 2D 2B 20 2E
	   20 7C 20 2E 20
	   2B 2D 2D 2D 2D
	   2D 2D 2B 20 2E
	   20 2B 2D 2D 2D
	   2D 2D 2D 2B 20
	   2E 20 7C
 0000009F  7C 20 6F 20 7C     C         BYTE "| o |      | . |      | . | . |      | . |      | o |"
	   20 20 20 20 20
	   20 7C 20 2E 20
	   7C 20 20 20 20
	   20 20 7C 20 2E
	   20 7C 20 2E 20
	   7C 20 20 20 20
	   20 20 7C 20 2E
	   20 7C 20 20 20
	   20 20 20 7C 20
	   6F 20 7C
 000000D4  7C 20 2E 20 2B     C         BYTE "| . +------+ . +------+ . | . +------+ . +------+ . |"
	   2D 2D 2D 2D 2D
	   2D 2B 20 2E 20
	   2B 2D 2D 2D 2D
	   2D 2D 2B 20 2E
	   20 7C 20 2E 20
	   2B 2D 2D 2D 2D
	   2D 2D 2B 20 2E
	   20 2B 2D 2D 2D
	   2D 2D 2D 2B 20
	   2E 20 7C
 00000109  7C 20 2E 20 2E     C         BYTE "| . . . . .  . . . . . . . . . . . . . . . . . . .  |"
	   20 2E 20 2E 20
	   2E 20 20 2E 20
	   2E 20 2E 20 2E
	   20 2E 20 2E 20
	   2E 20 2E 20 2E
	   20 2E 20 2E 20
	   2E 20 2E 20 2E
	   20 2E 20 2E 20
	   2E 20 2E 20 2E
	   20 20 7C
 0000013E  7C 20 2E 20 2D     C         BYTE "| . -------- . | . -------+------- . | . -------- . |"
	   2D 2D 2D 2D 2D
	   2D 2D 20 2E 20
	   7C 20 2E 20 2D
	   2D 2D 2D 2D 2D
	   2D 2B 2D 2D 2D
	   2D 2D 2D 2D 20
	   2E 20 7C 20 2E
	   20 2D 2D 2D 2D
	   2D 2D 2D 2D 20
	   2E 20 7C
 00000173  7C 20 2E 20 2E     C         BYTE "| . . . . .  . . . . . .  | . . . .  . . . . . . .  |"
	   20 2E 20 2E 20
	   2E 20 20 2E 20
	   2E 20 2E 20 2E
	   20 2E 20 2E 20
	   20 7C 20 2E 20
	   2E 20 2E 20 2E
	   20 20 2E 20 2E
	   20 2E 20 2E 20
	   2E 20 2E 20 2E
	   20 20 7C
 000001A8  2B 2D 2D 2D 2D     C         BYTE "+----------+ . +-------   |   -------+ . +----------+"
	   2D 2D 2D 2D 2D
	   2D 2B 20 2E 20
	   2B 2D 2D 2D 2D
	   2D 2D 2D 20 20
	   20 7C 20 20 20
	   2D 2D 2D 2D 2D
	   2D 2D 2B 20 2E
	   20 2B 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2B
 000001DD  20 20 20 20 20     C         BYTE "           | . |                     | . |           "
	   20 20 20 20 20
	   20 7C 20 2E 20
	   7C 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 7C 20 2E
	   20 7C 20 20 20
	   20 20 20 20 20
	   20 20 20
 00000212  7E 2D 2D 2D 2D     C         BYTE "~----------+ . |   +-------------+   | . +----------~"
	   2D 2D 2D 2D 2D
	   2D 2B 20 2E 20
	   7C 20 20 20 2B
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2B 20
	   20 20 7C 20 2E
	   20 2B 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 7E
 00000247  20 20 2E 20 2E     C         BYTE "  . . . . . .      |    A A A    |     . . . . . . . "
	   20 2E 20 2E 20
	   2E 20 2E 20 20
	   20 20 20 20 7C
	   20 20 20 20 41
	   20 41 20 41 20
	   20 20 20 7C 20
	   20 20 20 20 2E
	   20 2E 20 2E 20
	   2E 20 2E 20 2E
	   20 2E 20
 0000027C  7E 2D 2D 2D 2D     C         BYTE "~----------+ . |   +-------------+   | . +----------~"
	   2D 2D 2D 2D 2D
	   2D 2B 20 2E 20
	   7C 20 20 20 2B
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2B 20
	   20 20 7C 20 2E
	   20 2B 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 7E
 000002B1  20 20 20 20 20     C         BYTE "           | . |          @          | . |           "
	   20 20 20 20 20
	   20 7C 20 2E 20
	   7C 20 20 20 20
	   20 20 20 20 20
	   20 40 20 20 20
	   20 20 20 20 20
	   20 20 7C 20 2E
	   20 7C 20 20 20
	   20 20 20 20 20
	   20 20 20
 000002E6  2B 2D 2D 2D 2D     C         BYTE "+----------+ . |   -------+-------   | . +----------+"
	   2D 2D 2D 2D 2D
	   2D 2B 20 2E 20
	   7C 20 20 20 2D
	   2D 2D 2D 2D 2D
	   2D 2B 2D 2D 2D
	   2D 2D 2D 2D 20
	   20 20 7C 20 2E
	   20 2B 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2B
 0000031B  7C 20 2E 20 2E     C         BYTE "| . . . . . . . . . . . . | . . . . . . . . . . . . |"
	   20 2E 20 2E 20
	   2E 20 2E 20 2E
	   20 2E 20 2E 20
	   2E 20 2E 20 2E
	   20 7C 20 2E 20
	   2E 20 2E 20 2E
	   20 2E 20 2E 20
	   2E 20 2E 20 2E
	   20 2E 20 2E 20
	   2E 20 7C
 00000350  7C 20 2E 20 2D     C         BYTE "| . -------+ . -------- . | . -------  . +------- . |"
	   2D 2D 2D 2D 2D
	   2D 2B 20 2E 20
	   2D 2D 2D 2D 2D
	   2D 2D 2D 20 2E
	   20 7C 20 2E 20
	   2D 2D 2D 2D 2D
	   2D 2D 20 20 2E
	   20 2B 2D 2D 2D
	   2D 2D 2D 2D 20
	   2E 20 7C
 00000385  7C 20 2E 20 2E     C         BYTE "| . . . .  | . . . . . . . . . . . . | . . . . . .  |"
	   20 2E 20 2E 20
	   20 7C 20 2E 20
	   2E 20 2E 20 2E
	   20 2E 20 2E 20
	   2E 20 2E 20 2E
	   20 2E 20 2E 20
	   2E 20 7C 20 2E
	   20 2E 20 2E 20
	   2E 20 2E 20 2E
	   20 20 7C
 000003BA  2B 2D 2D 2D 2D     C         BYTE "+------- . | . | . ---------------   | . |   -------+"
	   2D 2D 2D 20 2E
	   20 7C 20 2E 20
	   7C 20 2E 20 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 20
	   20 20 7C 20 2E
	   20 7C 20 20 20
	   2D 2D 2D 2D 2D
	   2D 2D 2B
 000003EF  7C 20 2E 20 2E     C         BYTE "| . . . . . . .| . . . . . . . . . . | . . . . . .  |"
	   20 2E 20 2E 20
	   2E 20 2E 20 2E
	   7C 20 2E 20 2E
	   20 2E 20 2E 20
	   2E 20 2E 20 2E
	   20 2E 20 2E 20
	   2E 20 7C 20 2E
	   20 2E 20 2E 20
	   2E 20 2E 20 2E
	   20 20 7C
 00000424  7C 20 6F 20 2D     C         BYTE "| o -----------+------- . | . -------+----------- o |"
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2B 2D 2D 2D 2D
	   2D 2D 2D 20 2E
	   20 7C 20 2E 20
	   2D 2D 2D 2D 2D
	   2D 2D 2B 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 20
	   6F 20 7C
 00000459  7C 20 2E 20 2E     C         BYTE "| . . . . . . . . . . . . | . . . . . . . . . . .   |"
	   20 2E 20 2E 20
	   2E 20 2E 20 2E
	   20 2E 20 2E 20
	   2E 20 2E 20 2E
	   20 7C 20 2E 20
	   2E 20 2E 20 2E
	   20 2E 20 2E 20
	   2E 20 2E 20 2E
	   20 2E 20 2E 20
	   20 20 7C
 0000048E  2B 2D 2D 2D 2D     C         BYTE "+---------------------------------------------------+", 0 
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2B 00
			      C         
 = 00000017		      C     mapRow EQU 23
 = 00000035		      C     mapCol EQU 53
			      C     
 000004C4 1A		      C     col     BYTE 26
 000004C5 0D		      C     row     BYTE 13    
 000004C6 00000000	      C     score    DWORD 0   
 000004CA 00000000	      C     foodEaten DWORD 0
			      C 
 000004CE 64		      C     specialPowerLimit BYTE 100  ; total iteration counter for power
 000004CF 00		      C     specialPower BYTE ?       ;  
 000004D0 00000064	      C     speed DWORD 100
 000004D4 01 00 00 00	      C     pacmanMov movement <1,0,0,0>
			      C     
 = 00000004		      C     noOfEnemy EQU 4
 000004D8  00000004 [	      C     enemy enemyInfo noOfEnemy DUP(<26,9,0,0,0,1,26,9>)
	    1A 09 00 00
	    00 01 001A 09
	    09
	   ]
 = 00000028		      C     sizeOfEnemy EQU SIZEOF enemy
			      C     
 00000500 00000000	      C     tmp DWORD 0
 00000504 40		      C     pacman BYTE '@'
			      C 
 00000000			.code 
				    include PacmanControl.asm
 00000000		      C     getArrayVal PROC, x:BYTE, y:BYTE
 00000003  B8 00000000	      C         mov eax, 0
 00000008  8A 45 08	      C         mov al, x      ; ROW
 0000000B  B3 35	      C         mov bl, mapCol  ; TOTAL ROW
 0000000D  F6 E3	      C         mul bl
 0000000F  66| 0F BE 5D	      C         movsx bx, y
	   0C
 00000014  66| 03 C3	      C         add ax, bx      ; RESULT + COL
			      C           
 00000017  8A 80 00000000 R   C         mov al, map[eax]         
			      C         
			      C         .IF al != '|' && al != '-' && al != '+' 
 00000029  B4 01	      C             mov ah, 1
			      C         .ELSE 
 0000002D  B4 00	      C             mov ah, 0
			      C         .ENDIF
			      C         
			      C         ret
 00000033		      C     getArrayVal ENDP      
			      C         
 00000033		      C     isHurdle PROC, co:BYTE, r:BYTE, colAdd:BYTE, rowAdd:BYTE
 00000036  8A 55 08	      C         mov dl, co
 00000039  8A 75 0C	      C         mov dh, r
			      C         
 0000003C  02 55 10	      C         add dl, colAdd
 0000003F  02 75 14	      C         add dh, rowAdd
			      C         
			      C         invoke getArrayVal, dh, dl    ; return character in al and hurdle info in ah 
			      C         .IF ah
 00000051  02 55 10	      C             add dl, colAdd
			      C             ;add dh, rowAdd
			      C            invoke getArrayVal, dh, dl            
			      C         .ENDIF
			      C         ret
 00000063		      C     isHurdle ENDP 
			      C         
 00000063		      C     currentItem PROC
 00000063  B8 00000000	      C         mov eax, 0
 00000068  A0 000004C5 R      C         mov al, row      ; ROW
 0000006D  B3 35	      C         mov bl, mapCol  ; TOTAL ROW
 0000006F  F6 E3	      C         mul bl
 00000071  66| 0F BE 1D	      C         movsx bx, col
	   000004C4 R
 00000079  66| 03 C3	      C         add ax, bx      ; RESULT + 
			      C         
 0000007C  8A 98 00000000 R   C         mov bl, map[eax] 
			      C         .IF bl == '.'
 00000087  C6 80 00000000 R   C             mov map[eax] , ' '
	   20
 0000008E  FF 05 000004CA R   C             INC foodEaten
 00000094  FF 05 000004C6 R   C             INC score
			      C         .ELSEIF bl == 'o'
 000000A1  C6 80 00000000 R   C             mov map[eax] , ' '
	   20
 000000A8  8A 1D 000004CE R   C             mov bl, specialPowerLimit
 000000AE  88 1D 000004CF R   C             mov specialPower, bl
			      C         .ENDIF
			      C         
 000000B4  C3		      C         ret
 000000B5		      C     currentItem ENDP
			      C     
 000000B5		      C     setDirection PROC, up:BYTE,down:BYTE,left:BYTE,right:BYTE
 000000B8  8A 45 08	      C         mov al, up
 000000BB  A2 000004D4 R      C         mov pacmanMov.up, al
			      C 
 000000C0  8A 45 0C	      C         mov al, down
 000000C3  A2 000004D5 R      C         mov pacmanMov.down, al
			      C 
 000000C8  8A 45 10	      C         mov al, left
 000000CB  A2 000004D6 R      C         mov pacmanMov.left, al      
			      C         
 000000D0  8A 45 14	      C         mov al, right
 000000D3  A2 000004D7 R      C         mov pacmanMov.right, al        
			      C         
			      C         ret
 000000DC		      C     setDirection ENDP
			      C         
 000000DC		      C     keySync PROC
 000000DC  B4 00	      C         mov ah, 0
			      C         INVOKE GetKeyState, VK_DOWN
			      C         .IF ah && row < mapRow - 1 || pacmanMov.down
			      C             invoke isHurdle, col, row, 0, 1
			      C             .IF ah
 00000114  FE 05 000004C5 R   C                 INC row
			      C                 invoke SetDirection, 0, 1, 0, 0
			      C             .ENDIF 
			      C         .ENDIF
			      C 
 00000127  B4 00	      C         mov ah, 0
			      C         INVOKE GetKeyState, VK_UP
			      C         .IF ah && row > 1 || pacmanMov.up
			      C             invoke isHurdle, col, row, 0, -1
			      C             .IF ah 
 0000015F  FE 0D 000004C5 R   C                 DEC row
			      C                 invoke SetDirection, 1, 0, 0, 0
			      C             .ENDIF
			      C         .ENDIF     
			      C         
 00000172  B4 00	      C         mov ah, 0
			      C         INVOKE GetKeyState, VK_LEFT
			      C         .IF ah && col > 1 || pacmanMov.left
			      C             invoke isHurdle, col, row, -1, 0
			      C             .IF ah 
 000001AA  FE 0D 000004C4 R   C                 DEC col
			      C                 invoke SetDirection, 0, 0, 1, 0                
			      C             .ENDIF
			      C         .ENDIF  
			      C 
 000001BD  B4 00	      C         mov ah, 0
			      C         INVOKE GetKeyState, VK_RIGHT
			      C         .IF ah && col < mapCol || pacmanMov.right
			      C             invoke isHurdle, col, row, 1, 0
			      C             .IF ah
 000001F5  FE 05 000004C4 R   C                 INC col
			      C                 invoke SetDirection, 0, 0, 0, 1                
			      C             .ENDIF
			      C 
			      C         .ENDIF     
			      C         
			      C         .IF col == 0
 00000211  B4 34	      C             mov ah, mapCol - 1
 00000213  88 25 000004C4 R   C             mov col, ah
			      C         .ELSEIF col == mapCol - 1
 00000224  C6 05 000004C4 R   C             mov col, 0
	   00
			      C         .ENDIF
			      C         
 0000022B  C3		      C         ret
 0000022C		      C     keySync ENDP
			      C 
 0000022C		      C     printMap PROC
 0000022C  B2 00	      C         mov dl, 0   ; row
 0000022E  B6 00	      C         mov dh, 0   ; col
			      C                
			      C         .WHILE dl != mapRow
			      C             .WHILE dh != mapCol
			      C                     invoke getArrayVal, dl, dh      ; return char in al                  
 0000023F  E8 00000000 E      C                     call WriteChar
 00000244  FE C6	      C                     INC dh
			      C             .ENDW
 0000024B  B6 00	      C             mov dh, 0
 0000024D  E8 00000000 E      C             call Crlf
 00000252  FE C2	      C             inc dl
			      C         .ENDW
 00000259  C3		      C         ret
 0000025A		      C     printMap ENDP
			      C 
				    include enemyControl.asm
 0000025A		      C     eraseEnemy PROC
 0000025A  B9 00000000	      C         mov ecx, 0
			      C         
 0000025F  BA 00000000	      C         mov edx, 0
 00000264  89 15 00000500 R   C         mov tmp, edx
			      C 
			      C         .WHILE ecx < noOfEnemy 
 0000026C  8A 82 000004D8 R   C             mov al,enemy[edx].col
 00000272  8A A2 000004D9 R   C             mov ah,enemy[edx].row  
			      C             
			      C             mGotoxy al, ah 
 00000278  52		     1C 	push edx
 00000279  8A F4	     1C     mov  dh,ah
 0000027B  8A D0	     1C     mov  dl,al
 0000027D  E8 00000000 E     1C 	call Gotoxy
 00000282  5A		     1C 	pop  edx
 00000283  B0 20	      C             mov  al,' '     
 00000285  E8 00000000 E      C             call WriteChar
			      C                 
 0000028A  8A 82 000004D8 R   C             mov al,enemy[edx].col
 00000290  8A A2 000004D9 R   C             mov ah,enemy[edx].row
			      C             mGotoxy al, ah   
 00000296  52		     1C 	push edx
 00000297  8A F4	     1C     mov  dh,ah
 00000299  8A D0	     1C     mov  dl,al
 0000029B  E8 00000000 E     1C 	call Gotoxy
 000002A0  5A		     1C 	pop  edx
			      C                 
			      C             invoke getArrayVal, enemy[edx].row, enemy[edx].col      ; return char in al                  
 000002B4  E8 00000000 E      C             call WriteChar
			      C            
 000002B9  83 C2 0A	      C             add edx, SIZEOF enemyInfo 
 000002BC  89 15 00000500 R   C             mov tmp, edx  
			      C    
 000002C2  41		      C             inc ecx
			      C         .ENDW
 000002C8  C3		      C         ret
 000002C9		      C     eraseEnemy ENDP  
			      C     
 000002C9		      C     enemyDirection PROC, up:BYTE,down:BYTE,left:BYTE,right:BYTE
 000002CC  8B 15 00000500 R   C         mov edx, tmp    
 000002D2  8A 45 08	      C         mov al, up
 000002D5  88 82 000004DA R   C         mov enemy[edx].up, al
			      C 
 000002DB  8A 45 0C	      C         mov al, down
 000002DE  88 82 000004DB R   C         mov enemy[edx].down, al
			      C 
 000002E4  8A 45 10	      C         mov al, left
 000002E7  88 82 000004DC R   C         mov enemy[edx].left, al      
			      C         
 000002ED  8A 45 14	      C         mov al, right
 000002F0  88 82 000004DD R   C         mov enemy[edx].right, al        
			      C         ret
 000002FA		      C     enemyDirection ENDP    
			      C     
			      C     
 000002FA		      C     enemyCollide PROC
 000002FA  B9 00000000	      C         mov ecx, 0
 000002FF  BA 00000000	      C         mov edx, 0
 00000304  89 15 00000500 R   C         mov tmp, edx
			      C 
			      C         .WHILE ecx < noOfEnemy 
 0000030C  A0 000004C4 R      C             mov al, col
 00000311  8A 25 000004C5 R   C             mov ah, row
			      C             .IF enemy[edx].col == al && enemy[edx].row == ah
			      C                 .IF specialPower != 0 
			      C                     ; If collide with enemy and you have special power
 00000330  C7 05 000004C6 R   C                     mov score, 100
	   00000064
 0000033A  C6 82 000004D8 R   C                     mov enemy[edx].col, 23
	   17
 00000341  C6 82 000004D9 R   C                     mov enemy[edx].row, 9
	   09
 00000348  66| C7 82	      C                     mov enemy[edx].delay, 50
	   000004DE R
	   0032
			      C                     invoke enemyDirection, 0,0,0,1                 
 0000035E  B0 00	      C                     mov al, 0
 00000360  C3		      C                     ret
			      C                 .ELSE
 00000363  B0 01	      C                     mov al, 1
 00000365  C3		      C                     ret
			      C                 .ENDIF
			      C             .ENDIF
			      C    
 00000366  83 C2 0A	      C             add edx, SIZEOF enemyInfo 
 00000369  89 15 00000500 R   C             mov tmp, edx     
 0000036F  41		      C             inc ecx
			      C         .ENDW
 00000375  B0 00	      C         mov al, 0 
 00000377  C3		      C         ret
 00000378		      C     enemyCollide ENDP
			      C    
 00000378		      C     initEnemy PROC 
 00000378  B9 00000000	      C         mov ecx, 0
			      C         
 0000037D  BA 00000000	      C         mov edx, 0
 00000382  89 15 00000500 R   C         mov tmp, edx
			      C         
			      C         .WHILE ecx < noOfEnemy  
 0000038A  E8 00000000 E      C             call Randomize
 0000038F  B8 00000001	      C             mov  eax,1
 00000394  E8 00000000 E      C             call RandomRange
			      C             
			      C             .IF eax == 0
			      C                 invoke enemyDirection, 0,0,1,0
			      C             .ELSE
			      C                 invoke enemyDirection, 0,0,0,1
			      C             .ENDIF
			      C             
 000003B9  8B 15 00000500 R   C             mov edx, tmp
			      C             
 000003BF  B8 0000001E	      C             mov  eax,30
 000003C4  E8 00000000 E      C             call RandomRange
 000003C9  66| 89 82	      C             mov enemy[edx].delay, ax
	   000004DE R
			      C             
 000003D0  83 C2 0A	      C             add edx, SIZEOF enemyInfo 
 000003D3  89 15 00000500 R   C             mov tmp, edx            
			      C                 
 000003D9  41		      C             inc ecx
			      C         .ENDW
 000003DF  C3		      C         ret
 000003E0		      C     initEnemy ENDP
			      C    
 000003E0		      C     loadEnemy PROC                   
 000003E0  B9 00000000	      C         mov ecx, 0
			      C         
 000003E5  BA 00000000	      C         mov edx, 0
 000003EA  89 15 00000500 R   C         mov tmp, edx
			      C         
			      C         .WHILE ecx < noOfEnemy        
			      C             .IF enemy[edx].delay != 0
 000003FF  66| FF 8A	      C                 DEC enemy[edx].delay
	   000004DE R
			      C             .ELSE            
			      C                 .IF enemy[edx].left
			      C                     invoke isHurdle, enemy[edx].col, enemy[edx].row, -1, 0
			      C                     .IF ah
 00000433  8B 15 00000500 R   C                         mov edx, tmp
 00000439  FE 8A 000004D8 R   C                         DEC enemy[edx].col
			      C                     .ENDIF
			      C                 .ELSEIF enemy[edx].right
			      C                     invoke isHurdle, enemy[edx].col, enemy[edx].row, 1, 0
			      C                     .IF ah
 00000468  8B 15 00000500 R   C                         mov edx, tmp                     
 0000046E  FE 82 000004D8 R   C                         INC enemy[edx].col
			      C                     .ENDIF
			      C                 .ELSEIF enemy[edx].up
			      C                     invoke isHurdle, enemy[edx].col, enemy[edx].row, 0, -1
			      C                     .IF ah
 0000049A  8B 15 00000500 R   C                         mov edx, tmp                     
 000004A0  FE 8A 000004D9 R   C                         DEC enemy[edx].row
			      C                     .ENDIF
			      C                 .ELSEIF enemy[edx].down
			      C                     invoke isHurdle, enemy[edx].col, enemy[edx].row, 0, 1
			      C                     .IF ah
 000004CC  8B 15 00000500 R   C                         mov edx, tmp                     
 000004D2  FE 82 000004D9 R   C                         INC enemy[edx].row
			      C                     .ENDIF
			      C                 .ENDIF    
			      C                 
 000004D8  8B 15 00000500 R   C                 mov edx, tmp
			      C                 
			      C                 .IF ah == 0         ; Trigger when hurdle is found
 000004E6  E8 00000000 E      C                     call Randomize
 000004EB  B8 00000002	      C                     mov  eax,2
 000004F0  E8 00000000 E      C                     call RandomRange
			      C                     
			      C                     ; UP DOWN LEFT RIGHT
 000004F5  8B 15 00000500 R   C                     mov edx, tmp
			      C                     
			      C                     .IF enemy[edx].down == 1
			      C                         .IF eax
			      C                             invoke enemyDirection, 0,0,1,0 
			      C                         .ELSE
			      C                             invoke enemyDirection, 0,0,0,1                 
			      C                         .ENDIF
			      C                     .ELSEIF enemy[edx].up == 1
			      C                         .IF eax
			      C                             invoke enemyDirection, 0,0,1,0 
			      C                         .ELSE
			      C                             invoke enemyDirection, 0,0,0,1                 
			      C                         .ENDIF
			      C                     .ELSEIF enemy[edx].right == 1
			      C                         .IF eax
			      C                             invoke enemyDirection, 1,0,0,0 
			      C                         .ELSE
			      C                             invoke enemyDirection, 0,1,0,0                 
			      C                         .ENDIF
			      C                     .ELSEIF enemy[edx].left == 1
			      C                         .IF eax
			      C                             invoke enemyDirection, 1,0,0,0 
			      C                         .ELSE
			      C                             invoke enemyDirection, 0,1,0,0                 
			      C                         .ENDIF
			      C                     .ENDIF
			      C                    
			      C                 .ENDIF
			      C             .ENDIF
			      C             
 000005A8  8A 82 000004D8 R   C             mov al, enemy[edx].col
 000005AE  8A A2 000004D9 R   C             mov ah, enemy[edx].row
			      C                 
			      C             mGotoxy al, ah                            
 000005B4  52		     1C 	push edx
 000005B5  8A F4	     1C     mov  dh,ah
 000005B7  8A D0	     1C     mov  dl,al
 000005B9  E8 00000000 E     1C 	call Gotoxy
 000005BE  5A		     1C 	pop  edx
			      C             .IF specialPower == 0
			      C                 mWrite "E" 
 00000505		     1C 	.data				
 00000505 45 00		     1C 	??0000 BYTE "E",0		
 000005C8		     1C 	.code
 000005C8  52		     1C 	push edx
 000005C9  BA 00000505 R     1C 	mov  edx,OFFSET ??0000
 000005CE  E8 00000000 E     1C 	call Writestring
 000005D3  5A		     1C 	pop  edx
			      C             .ELSE    
			      C                 mWrite "e" 
 00000507		     1C 	.data				
 00000507 65 00		     1C 	??0001 BYTE "e",0		
 000005D6		     1C 	.code
 000005D6  52		     1C 	push edx
 000005D7  BA 00000507 R     1C 	mov  edx,OFFSET ??0001
 000005DC  E8 00000000 E     1C 	call Writestring
 000005E1  5A		     1C 	pop  edx
			      C             .ENDIF
			      C             
			      C                                         
 000005E2  83 C2 0A	      C             add edx, SIZEOF enemyInfo 
 000005E5  89 15 00000500 R   C             mov tmp, edx            
			      C                 
 000005EB  41		      C             inc ecx
			      C         .ENDW    
			      C         
 000005F5  C3		      C         ret
 000005F6		      C     loadEnemy ENDP
			      C 
				    
 000005F6			    main PROC       
 000005F6  E8 FFFFFD7D		        call initEnemy
 000005FB  E8 FFFFFC2C		        call printMap
 00000600			        forever:      
 00000600  E8 FFFFFDDB		            call loadEnemy
 00000605  E8 FFFFFCF0		            call enemyCollide
				            .IF al
 0000060E  E9 000000B9		                jmp GameOver
				            .ENDIF
				            
 00000613  E8 FFFFFAC4		            call keySync          ; sync keyboard
 00000618  E8 FFFFFA46		            call currentItem      ; Check for . and increase score
				            
				            mGotoxy col, row
 0000061D  52		     1		push edx
 0000061E  8A 35 000004C5 R  1	    mov  dh,row
 00000624  8A 15 000004C4 R  1	    mov  dl,col
 0000062A  E8 00000000 E     1		call Gotoxy
 0000062F  5A		     1		pop  edx
				            .IF specialPower == 0
 00000639  A0 00000504 R	                mov al,pacman     
				            .ELSEIF
 00000640  B0 01		                mov al, 1
 00000642  FE 0D 000004CF R	                DEC specialPower
				            .ENDIF
 00000648  E8 00000000 E	            call WriteChar  ; print out pacman
				    
				            invoke Sleep, speed
				                    
 00000658  E8 FFFFFBFD		            call eraseEnemy
				            
				            mGotoxy col, row
 0000065D  52		     1		push edx
 0000065E  8A 35 000004C5 R  1	    mov  dh,row
 00000664  8A 15 000004C4 R  1	    mov  dl,col
 0000066A  E8 00000000 E     1		call Gotoxy
 0000066F  5A		     1		pop  edx
 00000670  B0 20		            mov  al,' '     
 00000672  E8 00000000 E	            call WriteChar
				            
				            mGotoxy 60, 10
 00000677  52		     1		push edx
 00000678  B6 0A	     1	    mov  dh,10
 0000067A  B2 3C	     1	    mov  dl,60
 0000067C  E8 00000000 E     1		call Gotoxy
 00000681  5A		     1		pop  edx
				            mWrite "Score:" 
 00000509		     1		.data				
 00000509 53 63 6F 72 65     1		??0002 BYTE "Score:",0		
	   3A 00
 00000682		     1		.code
 00000682  52		     1		push edx
 00000683  BA 00000509 R     1		mov  edx,OFFSET ??0002
 00000688  E8 00000000 E     1		call Writestring
 0000068D  5A		     1		pop  edx
 0000068E  A1 000004C6 R	            mov eax, score
 00000693  E8 00000000 E	            call WriteInt

				            mGotoxy 60, 11

 00000698  52		     1		push edx
 00000699  B6 0B	     1	    mov  dh,11
 0000069B  B2 3C	     1	    mov  dl,60
 0000069D  E8 00000000 E     1		call Gotoxy
 000006A2  5A		     1		pop  edx
				            mWrite "Food Eaten:" 
 00000510		     1		.data				
 00000510 46 6F 6F 64 20     1		??0003 BYTE "Food Eaten:",0		
	   45 61 74 65 6E
	   3A 00
 000006A3		     1		.code
 000006A3  52		     1		push edx
 000006A4  BA 00000510 R     1		mov  edx,OFFSET ??0003
 000006A9  E8 00000000 E     1		call Writestring
 000006AE  5A		     1		pop  edx
 000006AF  A1 000004CA R	            mov eax, foodEaten
 000006B4  E8 00000000 E	            call Writeint
				            
				            .IF foodEaten == 220
 000006C5  EB 22		                jmp YouWin
				            .ENDIF
				            
 000006C7  E9 FFFFFF34		        jmp forever
				        
 000006CC			        GameOver:
 000006CC  E8 00000000 E	            call ClrScr
				            mGotoxy 35, 10
 000006D1  52		     1		push edx
 000006D2  B6 0A	     1	    mov  dh,10
 000006D4  B2 23	     1	    mov  dl,35
 000006D6  E8 00000000 E     1		call Gotoxy
 000006DB  5A		     1		pop  edx
				            mWrite "Game Over"
 0000051C		     1		.data				
 0000051C 47 61 6D 65 20     1		??0004 BYTE "Game Over",0		
	   4F 76 65 72 00
 000006DC		     1		.code
 000006DC  52		     1		push edx
 000006DD  BA 0000051C R     1		mov  edx,OFFSET ??0004
 000006E2  E8 00000000 E     1		call Writestring
 000006E7  5A		     1		pop  edx
 000006E8  C3			            ret

 000006E9			        YouWin:
 000006E9  E8 00000000 E	            call ClrScr
				            mGotoxy 35, 7
 000006EE  52		     1		push edx
 000006EF  B6 07	     1	    mov  dh,7
 000006F1  B2 23	     1	    mov  dl,35
 000006F3  E8 00000000 E     1		call Gotoxy
 000006F8  5A		     1		pop  edx
				            mWrite "You Win"
 00000526		     1		.data				
 00000526 59 6F 75 20 57     1		??0005 BYTE "You Win",0		
	   69 6E 00
 000006F9		     1		.code
 000006F9  52		     1		push edx
 000006FA  BA 00000526 R     1		mov  edx,OFFSET ??0005
 000006FF  E8 00000000 E     1		call Writestring
 00000704  5A		     1		pop  edx
				            
				            mGotoxy 35, 10
 00000705  52		     1		push edx
 00000706  B6 0A	     1	    mov  dh,10
 00000708  B2 23	     1	    mov  dl,35
 0000070A  E8 00000000 E     1		call Gotoxy
 0000070F  5A		     1		pop  edx
				            mWrite "Score:" 
 0000052E		     1		.data				
 0000052E 53 63 6F 72 65     1		??0006 BYTE "Score:",0		
	   3A 00
 00000710		     1		.code
 00000710  52		     1		push edx
 00000711  BA 0000052E R     1		mov  edx,OFFSET ??0006
 00000716  E8 00000000 E     1		call Writestring
 0000071B  5A		     1		pop  edx
 0000071C  A1 000004C6 R	            mov eax, score
 00000721  E8 00000000 E	            call WriteInt

				            mGotoxy 35, 11
 00000726  52		     1		push edx
 00000727  B6 0B	     1	    mov  dh,11
 00000729  B2 23	     1	    mov  dl,35
 0000072B  E8 00000000 E     1		call Gotoxy
 00000730  5A		     1		pop  edx
				            mWrite "Food Eaten:" 
 00000535		     1		.data				
 00000535 46 6F 6F 64 20     1		??0007 BYTE "Food Eaten:",0		
	   45 61 74 65 6E
	   3A 00
 00000731		     1		.code
 00000731  52		     1		push edx
 00000732  BA 00000535 R     1		mov  edx,OFFSET ??0007
 00000737  E8 00000000 E     1		call Writestring
 0000073C  5A		     1		pop  edx
 0000073D  A1 000004CA R	            mov eax, foodEaten
 00000742  E8 00000000 E	            call Writeint
 00000747  C3			            ret
				        
 00000748  C3			        ret
 00000749			    main ENDP
				END main
Microsoft (R) Macro Assembler Version 6.15.8803		    08/30/15 16:16:02
Pacman.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

IsDefined  . . . . . . . . . . .	Func
NewLine  . . . . . . . . . . . .	Proc
ShowFlag . . . . . . . . . . . .	Proc
ShowRegister . . . . . . . . . .	Proc
Startup  . . . . . . . . . . . .	Proc
WriteSpace . . . . . . . . . . .	Proc
mDumpMem . . . . . . . . . . . .	Proc
mGotoxy  . . . . . . . . . . . .	Proc
mNewLine . . . . . . . . . . . .	Proc
mReadStr . . . . . . . . . . . .	Proc
mWriteLn . . . . . . . . . . . .	Proc
mWriteStr  . . . . . . . . . . .	Proc
mWrite . . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CONSOLE_CURSOR_INFO  . . . . . .	 00000005
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  bVisible . . . . . . . . . . .	 00000004	 Byte
CONSOLE_SCREEN_BUFFER_INFO . . .	 00000016
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCursorPos  . . . . . . . . .	 00000004	 DWord
  wAttributes  . . . . . . . . .	 00000008	 Word
  srWindow . . . . . . . . . . .	 0000000A	 QWord
  maxWinSize . . . . . . . . . .	 00000012	 DWord
COORD  . . . . . . . . . . . . .	 00000004
  X  . . . . . . . . . . . . . .	 00000000	 Word
  Y  . . . . . . . . . . . . . .	 00000002	 Word
FILETIME . . . . . . . . . . . .	 00000008
  loDateTime . . . . . . . . . .	 00000000	 DWord
  hiDateTime . . . . . . . . . .	 00000004	 DWord
SMALL_RECT . . . . . . . . . . .	 00000008
  Left . . . . . . . . . . . . .	 00000000	 Word
  Top  . . . . . . . . . . . . .	 00000002	 Word
  Right  . . . . . . . . . . . .	 00000004	 Word
  Bottom . . . . . . . . . . . .	 00000006	 Word
SYSTEMTIME . . . . . . . . . . .	 00000010
  wYear  . . . . . . . . . . . .	 00000000	 Word
  wMonth . . . . . . . . . . . .	 00000002	 Word
  wDayOfWeek . . . . . . . . . .	 00000004	 Word
  wDay . . . . . . . . . . . . .	 00000006	 Word
  wHour  . . . . . . . . . . . .	 00000008	 Word
  wMinute  . . . . . . . . . . .	 0000000A	 Word
  wSecond  . . . . . . . . . . .	 0000000C	 Word
  wMilliseconds  . . . . . . . .	 0000000E	 Word
enemyInfo  . . . . . . . . . . .	 0000000A
  col  . . . . . . . . . . . . .	 00000000	 Byte
  row  . . . . . . . . . . . . .	 00000001	 Byte
  up . . . . . . . . . . . . . .	 00000002	 Byte
  down . . . . . . . . . . . . .	 00000003	 Byte
  left . . . . . . . . . . . . .	 00000004	 Byte
  right  . . . . . . . . . . . .	 00000005	 Byte
  Delay  . . . . . . . . . . . .	 00000006	 Word
  hrow . . . . . . . . . . . . .	 00000008	 Byte
  hcol . . . . . . . . . . . . .	 00000009	 Byte
movement . . . . . . . . . . . .	 00000004
  up . . . . . . . . . . . . . .	 00000000	 Byte
  down . . . . . . . . . . . . .	 00000001	 Byte
  left . . . . . . . . . . . . .	 00000002	 Byte
  right  . . . . . . . . . . . .	 00000003	 Byte


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 DWord	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000541 DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000749 DWord	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ClrScr . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Crlf . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Delay  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpMem  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpRegs . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandTail . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDateTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyState  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMseconds  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Gotoxy . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsDigit  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Random32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RandomRange  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Randomize  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadChar . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadHex  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadInt  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadString . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_compare  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_copy . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_length . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_trim . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_ucase  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitMsg  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBin . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteChar  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteDec . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHex . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteInt . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteString  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
currentItem  . . . . . . . . . .	P Near	 00000063 _TEXT	Length= 00000052 Public STDCALL
enemyCollide . . . . . . . . . .	P Near	 000002FA _TEXT	Length= 0000007E Public STDCALL
enemyDirection . . . . . . . . .	P Near	 000002C9 _TEXT	Length= 00000031 Public STDCALL
  up . . . . . . . . . . . . . .	Byte	 bp + 00000008
  down . . . . . . . . . . . . .	Byte	 bp + 0000000C
  left . . . . . . . . . . . . .	Byte	 bp + 00000010
  right  . . . . . . . . . . . .	Byte	 bp + 00000014
eraseEnemy . . . . . . . . . . .	P Near	 0000025A _TEXT	Length= 0000006F Public STDCALL
getArrayVal  . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000033 Public STDCALL
  x  . . . . . . . . . . . . . .	Byte	 bp + 00000008
  y  . . . . . . . . . . . . . .	Byte	 bp + 0000000C
initEnemy  . . . . . . . . . . .	P Near	 00000378 _TEXT	Length= 00000068 Public STDCALL
isHurdle . . . . . . . . . . . .	P Near	 00000033 _TEXT	Length= 00000030 Public STDCALL
  co . . . . . . . . . . . . . .	Byte	 bp + 00000008
  r  . . . . . . . . . . . . . .	Byte	 bp + 0000000C
  colAdd . . . . . . . . . . . .	Byte	 bp + 00000010
  rowAdd . . . . . . . . . . . .	Byte	 bp + 00000014
keySync  . . . . . . . . . . . .	P Near	 000000DC _TEXT	Length= 00000150 Public STDCALL
loadEnemy  . . . . . . . . . . .	P Near	 000003E0 _TEXT	Length= 00000216 Public STDCALL
main . . . . . . . . . . . . . .	P Near	 000005F6 _TEXT	Length= 00000153 Public STDCALL
  forever  . . . . . . . . . . .	L Near	 00000600 _TEXT	
  GameOver . . . . . . . . . . .	L Near	 000006CC _TEXT	
  YouWin . . . . . . . . . . . .	L Near	 000006E9 _TEXT	
printMap . . . . . . . . . . . .	P Near	 0000022C _TEXT	Length= 0000002E Public STDCALL
setDirection . . . . . . . . . .	P Near	 000000B5 _TEXT	Length= 00000027 Public STDCALL
  up . . . . . . . . . . . . . .	Byte	 bp + 00000008
  down . . . . . . . . . . . . .	Byte	 bp + 0000000C
  left . . . . . . . . . . . . .	Byte	 bp + 00000010
  right  . . . . . . . . . . . .	Byte	 bp + 00000014


Symbols:

                N a m e                 Type     Value    Attr

??0000 . . . . . . . . . . . . .	Byte	 00000505 _DATA	
??0001 . . . . . . . . . . . . .	Byte	 00000507 _DATA	
??0002 . . . . . . . . . . . . .	Byte	 00000509 _DATA	
??0003 . . . . . . . . . . . . .	Byte	 00000510 _DATA	
??0004 . . . . . . . . . . . . .	Byte	 0000051C _DATA	
??0005 . . . . . . . . . . . . .	Byte	 00000526 _DATA	
??0006 . . . . . . . . . . . . .	Byte	 0000052E _DATA	
??0007 . . . . . . . . . . . . .	Byte	 00000535 _DATA	
@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
CREATE_ALWAYS  . . . . . . . . .	Number	 00000002h   
CREATE_NEW . . . . . . . . . . .	Number	 00000001h   
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
DO_NOT_SHARE . . . . . . . . . .	Number	 00000000h   
ENABLE_ECHO_INPUT  . . . . . . .	Number	 00000004h   
ENABLE_LINE_INPUT  . . . . . . .	Number	 00000002h   
ENABLE_MOUSE_INPUT . . . . . . .	Number	 00000010h   
ENABLE_PROCESSED_INPUT . . . . .	Number	 00000001h   
ENABLE_PROCESSED_OUTPUT  . . . .	Number	 00000001h   
ENABLE_WINDOW_INPUT  . . . . . .	Number	 00000008h   
ENABLE_WRAP_AT_EOL_OUTPUT  . . .	Number	 00000002h   
FALSE  . . . . . . . . . . . . .	Number	 00000000h   
FILE_APPEND_DATA . . . . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_ARCHIVE . . . . .	Number	 00000020h   
FILE_ATTRIBUTE_COMPRESSED  . . .	Number	 00000800h   
FILE_ATTRIBUTE_DEVICE  . . . . .	Number	 00000040h   
FILE_ATTRIBUTE_DIRECTORY . . . .	Number	 00000010h   
FILE_ATTRIBUTE_ENCRYPTED . . . .	Number	 00004000h   
FILE_ATTRIBUTE_HIDDEN  . . . . .	Number	 00000002h   
FILE_ATTRIBUTE_NORMAL  . . . . .	Number	 00000080h   
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED .	Number	 00002000h   
FILE_ATTRIBUTE_OFFLINE . . . . .	Number	 00001000h   
FILE_ATTRIBUTE_READONLY  . . . .	Number	 00000001h   
FILE_ATTRIBUTE_REPARSE_POINT . .	Number	 00000400h   
FILE_ATTRIBUTE_SPARSE_FILE . . .	Number	 00000200h   
FILE_ATTRIBUTE_SYSTEM  . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_TEMPORARY . . . .	Number	 00000100h   
FILE_BEGIN . . . . . . . . . . .	Number	 00000000h   
FILE_CURRENT . . . . . . . . . .	Number	 00000001h   
FILE_DELETE_CHILD  . . . . . . .	Number	 00000040h   
FILE_END . . . . . . . . . . . .	Number	 00000002h   
FILE_READ_DATA . . . . . . . . .	Number	 00000001h   
FILE_SHARE_DELETE  . . . . . . .	Number	 00000004h   
FILE_SHARE_READ  . . . . . . . .	Number	 00000001h   
FILE_SHARE_WRITE . . . . . . . .	Number	 00000002h   
FILE_WRITE_DATA  . . . . . . . .	Number	 00000002h   
FOCUS_EVENT  . . . . . . . . . .	Number	 00000010h   
GENERIC_ALL  . . . . . . . . . .	Number	 10000000h   
GENERIC_EXECUTE  . . . . . . . .	Number	 20000000h   
GENERIC_READ . . . . . . . . . .	Number	 -80000000h   
GENERIC_WRITE  . . . . . . . . .	Number	 40000000h   
INVALID_HANDLE_VALUE . . . . . .	Number	 -00000001h   
KEY_EVENT  . . . . . . . . . . .	Number	 00000001h   
MENU_EVENT . . . . . . . . . . .	Number	 00000008h   
MOUSE_EVENT  . . . . . . . . . .	Number	 00000002h   
NULL . . . . . . . . . . . . . .	Number	 00000000h   
OPEN_ALWAYS  . . . . . . . . . .	Number	 00000004h   
OPEN_EXISTING  . . . . . . . . .	Number	 00000003h   
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
STD_INPUT_HANDLE . . . . . . . .	Number	 -0000000Ah   
STD_OUTPUT_HANDLE  . . . . . . .	Number	 -0000000Bh   
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
TRUE . . . . . . . . . . . . . .	Number	 00000001h   
TRUNCATE_EXISTING  . . . . . . .	Number	 00000005h   
VK_DOWN  . . . . . . . . . . . .	Number	 00000028h   
VK_LEFT  . . . . . . . . . . . .	Number	 00000025h   
VK_RIGHT . . . . . . . . . . . .	Number	 00000027h   
VK_UP  . . . . . . . . . . . . .	Number	 00000026h   
WINDOW_BUFFER_SIZE_EVENT . . . .	Number	 00000004h   
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
black  . . . . . . . . . . . . .	Number	 00000000h   
blue . . . . . . . . . . . . . .	Number	 00000001h   
brown  . . . . . . . . . . . . .	Number	 00000006h   
col  . . . . . . . . . . . . . .	Byte	 000004C4 _DATA	
cyan . . . . . . . . . . . . . .	Number	 00000003h   
enemy  . . . . . . . . . . . . .	enemyInfo  000004D8 _DATA	
exit . . . . . . . . . . . . . .	Text   	 INVOKE ExitProcess,0
foodEaten  . . . . . . . . . . .	DWord	 000004CA _DATA	
gray . . . . . . . . . . . . . .	Number	 00000008h   
green  . . . . . . . . . . . . .	Number	 00000002h   
lightBlue  . . . . . . . . . . .	Number	 00000009h   
lightCyan  . . . . . . . . . . .	Number	 0000000Bh   
lightGray  . . . . . . . . . . .	Number	 00000007h   
lightGreen . . . . . . . . . . .	Number	 0000000Ah   
lightMagenta . . . . . . . . . .	Number	 0000000Dh   
lightRed . . . . . . . . . . . .	Number	 0000000Ch   
magenta  . . . . . . . . . . . .	Number	 00000005h   
mapCol . . . . . . . . . . . . .	Number	 00000035h   
mapRow . . . . . . . . . . . . .	Number	 00000017h   
map  . . . . . . . . . . . . . .	Byte	 00000000 _DATA	
maxCol . . . . . . . . . . . . .	Number	 0000004Fh   
maxRow . . . . . . . . . . . . .	Number	 00000016h   
noOfEnemy  . . . . . . . . . . .	Number	 00000004h   
pacmanMov  . . . . . . . . . . .	movement  000004D4 _DATA	
pacman . . . . . . . . . . . . .	Byte	 00000504 _DATA	
red  . . . . . . . . . . . . . .	Number	 00000004h   
row  . . . . . . . . . . . . . .	Byte	 000004C5 _DATA	
score  . . . . . . . . . . . . .	DWord	 000004C6 _DATA	
sizeOfEnemy  . . . . . . . . . .	Number	 00000028h   
specialPowerLimit  . . . . . . .	Byte	 000004CE _DATA	
specialPower . . . . . . . . . .	Byte	 000004CF _DATA	
speed  . . . . . . . . . . . . .	DWord	 000004D0 _DATA	
tmp  . . . . . . . . . . . . . .	DWord	 00000500 _DATA	
white  . . . . . . . . . . . . .	Number	 0000000Fh   
yellow . . . . . . . . . . . . .	Number	 0000000Eh   

	   0 Warnings
	   0 Errors
