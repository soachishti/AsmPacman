[33mcommit dc4bbae1e17d012d437ebdc7bab2cc10f33daf16[m
Author: soachishti <soac@outlook.com>
Date:   Wed Aug 26 23:22:42 2015 +0500

    Minor Fix

[1mdiff --git a/Pacman.asm b/Pacman.asm[m
[1mindex 662a9ef..a757998 100644[m
[1m--- a/Pacman.asm[m
[1m+++ b/Pacman.asm[m
[36m@@ -102,11 +102,11 @@[m [melementInfo ENDS[m
         add dh, rowAdd[m
         [m
         invoke getArrayVal, dh, dl    ; return character in al and hurdle info in ah [m
[31m-        .IF ah[m
[31m-            add dl, colAdd[m
[32m+[m[32m        ;.IF ah[m
[32m+[m[32m        ;    add dl, colAdd[m
             ;add dh, rowAdd[m
[31m-            invoke getArrayVal, dh, dl            [m
[31m-        .ENDIF[m
[32m+[m[32m        ;    invoke getArrayVal, dh, dl[m[41m            [m
[32m+[m[32m        ;.ENDIF[m
         ret[m
     isHurdle ENDP[m
 [m
[1mdiff --git a/Pacman.exe b/Pacman.exe[m
[1mindex 2d00e9d..a6fccdf 100644[m
Binary files a/Pacman.exe and b/Pacman.exe differ
[1mdiff --git a/Pacman.ilk b/Pacman.ilk[m
[1mindex b1b8924..474bbbb 100644[m
Binary files a/Pacman.ilk and b/Pacman.ilk differ
[1mdiff --git a/Pacman.lst b/Pacman.lst[m
[1mindex 72ed975..9d8d1ab 100644[m
[1m--- a/Pacman.lst[m
[1m+++ b/Pacman.lst[m
[36m@@ -1,8 +1,13 @@[m
[31m-Microsoft (R) Macro Assembler Version 6.15.8803		    08/26/15 23:16:22[m
[32m+[m[32mMicrosoft (R) Macro Assembler Version 6.15.8803		    08/26/15 23:22:00[m
 Pacman.asm						     Page 1 - 1[m
 [m
 [m
 				; 214 dots[m
[32m+[m				[32m; Game over when enemy col and row equal pacmanMov col and row[m
[32m+[m				[32m; Randomness of enemy movement[m
[32m+[m				[32m; Enemy only trigger after colliding[m
[32m+[m				[32m;   - Try to move when turn comes[m
[32m+[m
 [m
 				include irvine32.inc[m
 			      C ; Include file for Irvine32.lib             (Irvine32.inc)[m
[36m@@ -345,57 +350,57 @@[m [mPacman.asm						     Page 1 - 1[m
  0000003F  02 75 14		        add dh, rowAdd[m
 				        [m
 				        invoke getArrayVal, dh, dl    ; return character in al and hurdle info in ah [m
[31m-				        .IF ah[m
[31m- 00000051  02 55 10		            add dl, colAdd[m
[32m+[m				[32m        ;.IF ah[m
[32m+[m				[32m        ;    add dl, colAdd[m
 				            ;add dh, rowAdd[m
[31m-				            invoke getArrayVal, dh, dl            [m
[31m-				        .ENDIF[m
[32m+[m				[32m        ;    invoke getArrayVal, dh, dl[m[41m            [m
[32m+[m				[32m        ;.ENDIF[m
 				        ret[m
[31m- 00000063			    isHurdle ENDP[m
[32m+[m[32m 00000051			    isHurdle ENDP[m
 [m
[31m- 00000063			    enemyDirection PROC, up:BYTE,down:BYTE,left:BYTE,right:BYTE[m
[31m- 00000066  8A 45 08		        mov al, up[m
[31m- 00000069  A2 000004D6 R	        mov enemy.up, al[m
[32m+[m[32m 00000051			    enemyDirection PROC, up:BYTE,down:BYTE,left:BYTE,right:BYTE[m
[32m+[m[32m 00000054  8A 45 08		        mov al, up[m
[32m+[m[32m 00000057  A2 000004D6 R	        mov enemy.up, al[m
 [m
[31m- 0000006E  8A 45 0C		        mov al, down[m
[31m- 00000071  A2 000004D7 R	        mov enemy.down, al[m
[32m+[m[32m 0000005C  8A 45 0C		        mov al, down[m
[32m+[m[32m 0000005F  A2 000004D7 R	        mov enemy.down, al[m
 [m
[31m- 00000076  8A 45 10		        mov al, left[m
[31m- 00000079  A2 000004D8 R	        mov enemy.left, al      [m
[32m+[m[32m 00000064  8A 45 10		        mov al, left[m
[32m+[m[32m 00000067  A2 000004D8 R	        mov enemy.left, al[m[41m      [m
 				        [m
[31m- 0000007E  8A 45 14		        mov al, right[m
[31m- 00000081  A2 000004D9 R	        mov enemy.right, al        [m
[32m+[m[32m 0000006C  8A 45 14		        mov al, right[m
[32m+[m[32m 0000006F  A2 000004D9 R	        mov enemy.right, al[m[41m        [m
 				        ret[m
[31m- 0000008A			    enemyDirection ENDP[m
[32m+[m[32m 00000078			    enemyDirection ENDP[m
 				   [m
[31m- 0000008A			    loadEnemy PROC                   [m
[32m+[m[32m 00000078			    loadEnemy PROC[m[41m                   [m
 				           .IF enemy.left[m
 				            invoke isHurdle, enemy.col, enemy.row, -1, 0[m
 				            .IF ah[m
[31m- 000000B0  FE 0D 000004D4 R	                DEC enemy.col[m
[32m+[m[32m 0000009E  FE 0D 000004D4 R	                DEC enemy.col[m
 				            .ENDIF[m
 				        .ELSEIF enemy.right[m
 				            invoke isHurdle, enemy.col, enemy.row, 1, 0[m
 				            .IF ah[m
[31m- 000000DA  FE 05 000004D4 R	                INC enemy.col[m
[32m+[m[32m 000000C8  FE 05 000004D4 R	                INC enemy.col[m
 				            .ENDIF[m
 				        .ELSEIF enemy.up[m
 				            invoke isHurdle, enemy.col, enemy.row, 0, -1[m
 				            .IF ah[m
[31m- 00000104  FE 0D 000004D5 R	                DEC enemy.row[m
[32m+[m[32m 000000F2  FE 0D 000004D5 R	                DEC enemy.row[m
 				            .ENDIF[m
 				        .ELSEIF enemy.down[m
 				            invoke isHurdle, enemy.col, enemy.row, 0, 1[m
 				            .IF ah[m
[31m- 0000012E  FE 05 000004D5 R	                INC enemy.row[m
[32m+[m[32m 0000011C  FE 05 000004D5 R	                INC enemy.row[m
 				            .ENDIF[m
 				        .ENDIF    [m
 				        [m
 				        .IF ah == 0         ; Trigger when hurdle is found[m
[31m- 0000013C			            weNeedRes:[m
[31m- 0000013C  B8 00000003		            mov  eax,3[m
[31m- 00000141  E8 00000000 E	            call RandomRange[m
[31m- 00000146  E8 00000000 E	            call Randomize[m
[32m+[m[32m 0000012A			            weNeedRes:[m
[32m+[m[32m 0000012A  B8 00000003		            mov  eax,3[m
[32m+[m[32m 0000012F  E8 00000000 E	            call RandomRange[m
[32m+[m[32m 00000134  E8 00000000 E	            call Randomize[m
 				            [m
 				            .IF eax == 0 && enemy.up == 0 && enemy.down == 0[m
 				                invoke enemyDirection, 1, 0, 0, 0[m
[36m@@ -406,215 +411,215 @@[m [mPacman.asm						     Page 1 - 1[m
 				            .ELSEIF eax == 3 && enemy.right == 0 && enemy.left == 0   [m
 				                invoke enemyDirection, 0, 0, 0, 1        [m
 				            .ELSE [m
[31m- 000001E2  E9 FFFFFF55		                jmp weNeedRes[m
[32m+[m[32m 000001D0  E9 FFFFFF55		                jmp weNeedRes[m
 				            .ENDIF[m
 				            [m
 				        .ENDIF[m
 				        [m
 				                    mGotoxy enemy.col, enemy.row            [m
[31m- 000001E7  52		     1		push edx[m
[31m- 000001E8  8A 35 000004D5 R  1	    mov  dh,enemy.row[m
[31m- 000001EE  8A 15 000004D4 R  1	    mov  dl,enemy.col[m
[31m- 000001F4  E8 00000000 E     1		call Gotoxy[m
[31m- 000001F9  5A		     1		pop  edx[m
[32m+[m[32m 000001D5  52		     1		push edx[m
[32m+[m[32m 000001D6  8A 35 000004D5 R  1	    mov  dh,enemy.row[m
[32m+[m[32m 000001DC  8A 15 000004D4 R  1	    mov  dl,enemy.col[m
[32m+[m[32m 000001E2  E8 00000000 E     1		call Gotoxy[m
[32m+[m[32m 000001E7  5A		     1		pop  edx[m
 				            mWrite "A" [m
  000004DF		     1		.data				[m
  000004DF 41 00		     1		??0000 BYTE "A",0		[m
[31m- 000001FA		     1		.code[m
[31m- 000001FA  52		     1		push edx[m
[31m- 000001FB  BA 000004DF R     1		mov  edx,OFFSET ??0000[m
[31m- 00000200  E8 00000000 E     1		call Writestring[m
[31m- 00000205  5A		     1		pop  edx[m
[32m+[m[32m 000001E8		     1		.code[m
[32m+[m[32m 000001E8  52		     1		push edx[m
[32m+[m[32m 000001E9  BA 000004DF R     1		mov  edx,OFFSET ??0000[m
[32m+[m[32m 000001EE  E8 00000000 E     1		call Writestring[m
[32m+[m[32m 000001F3  5A		     1		pop  edx[m
 				        [m
 				        [m
[31m- 00000206  C3			        ret[m
[31m- 00000207			    loadEnemy ENDP[m
[32m+[m[32m 000001F4  C3			        ret[m
[32m+[m[32m 000001F5			    loadEnemy ENDP[m
 				    [m
 [m
[31m- 00000207			    currentItem PROC[m
[31m- 00000207  B8 00000000		        mov eax, 0[m
[31m- 0000020C  A0 000004C5 R	        mov al, row      ; ROW[m
[31m- 00000211  B3 35		        mov bl, mapCol  ; TOTAL ROW[m
